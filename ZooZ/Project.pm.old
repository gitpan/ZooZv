package ZooZ::Project;

use strict;
use ZooZ::DefaultArgs;
use Tk;
use Tk::LabFrame;

my $cellWidth   = 50;
my $cellHeight  = 30;
my $handleSize  = 5;
my $handleColor = 'white';
#my $resizeTh    = 10; # resize threshold
my $selColor    = 'orange';
my $bgColor     = 'dimgray';
my $cellBg      = 'white';
my $handleBits  = 0;
my $topPadding  = 20;
my $intPadding  = 5;

my $dropsEnable = 0;

my $isContainer = qr/^(?:Tk::)?(?:Lab(?:el)?)?[Ff]rame$/;

#####
#
# description of data structure used.
#
#####
#
# {CELL2FRAME}[$row][$col]  = $cell_frame
# {FRAME2CELL}{$cell_frame} = [$row, $col]
# {USED}[$row][$col]        = 0/[Image label, Name Label]
# {CELLCONFIG}[$row][$col]->
#                           {COLUMNSPAN} = num
#                           {ROWSPAN}    = num
#                           {PADX}       = num
#                           {PADY}       = num
#                           {STICKY}     = string
# {MISSING}[$row][$col] = 0/1 whether a cell is missing or not.
#         a cell becomes missing when it is merged with another cell.
# {MERGED}[$row][$col] = 0/1   opposite of MISSING
#         a cell is merged when it takes over the location of another cell.
# {SPECIAL2OBJ}{$widget} = ProjectObject
# {DESTROY} = [widget objects to be destroyed]
# {WIDGETS}[$row][$col] = widget type/widget object
#                  before object is created, this contains what kind
#                  of widget to add at ($row, $col). After creation
#                  it will contain the actual widget.
# {WIDGET2NAME}{$widget} = $name
# {DROPSITES}{$cell} = DropSite object
# {STRING2OBJ}{$cell} = $cell
# {DND}[$r][$c]       = DragDrop object
# {WIDGET_MOVE}       = []/[$r,$c]  whether we are moving a widget or
#                                  dropping a new one
#

# creates a new Project object and returns it.
sub new {
  my ($class, %args) = @_;

  $class = ref($class) || $class;

  my $self = bless {
		    ID          => $args{-id},
		    PARENT      => $args{-parent},
		    TOP_PARENT  => $args{-top_parent} || $args{-parent},
		    TREE        => $args{-tree},
		    NAME        => $args{-name},
		    TITLE       => $args{-title},
		    ROWS        => $args{-rows}        || 3,
		    COLS        => $args{-cols}        || 3,
		    SELREF      => $args{-selref},
		    ICONS       => $args{-icons},
		    IDS         => $args{-ids}         || {},
		    PREV        => undef,   # preview window ref.
		    ISCHILD     => $args{-ischild}     || 0,
		    CELLBG      => $args{-cellbg}      || $cellBg,
		    PREVTOP     => $args{-prevtop}     || '',
		    WIDGET_MOVE => $args{-widget_move} || [],
		    SELECTED    => $args{-selected}    || [],
		    SPECIAL2OBJ => {},
		   } => $class;

  # create the grid.
  $self->_createGrid;

  # create the menu.
  $self->_createMenu;

  # create the preview window.
  $self->_createPreview;
  #print "Returning self $self.\n";
  return $self;
}

# creates the initial grid of cells along with the handles.
sub _createGrid {
  my $self = shift;

  my $f = $self->{PARENT}->Frame(-bg          => $bgColor,
				 -relief      => 'sunken',
				 -borderwidth => 2,
				)->pack(qw/-fill both -expand 1/);

  $self->{FRAME} = $f->Frame(-bg => $bgColor,
			    )->pack(qw/-expand 0 -anchor nw/,
				    -padx => $self->{ISCHILD} ? $intPadding : $topPadding,
				    -pady => $self->{ISCHILD} ? $intPadding : $topPadding,
				   );

  $self->{BACKFRAME} = $f;

  # now create the cells.
  for my $r (0 .. $self->{ROWS} - 1) {
    for my $c (0 .. $self->{COLS} - 1) {
      $self->_addCell($r, $c);
    }
  }

  # create the handle bitmaps if we have to.
  unless ($handleBits) {
    $self->_createHandleBitmaps;
    $handleBits = 1;
  }

  # and create the resize handles.
  $self->_createHandleH;
  $self->_createHandleV;

  # bind clicks to the back frame.
  $f->bind('<1>' => [$self, '_unselectCell']);
}

# used to center the handles along the edges
sub _centerHandles {
  my $self = shift;

  my ($cols, $rows) = $self->{FRAME}->gridSize;

  $self->{HANDLEH}->grid(-column  => $cols - 1,
			 -row     => 0,
			 -rowspan => $rows,
			 -sticky  => 'ns');

  $self->{HANDLEV}->grid(-columnspan => $cols,
			 -column     => 0,
			 -row        => $rows - 1,
			 -sticky  => 'ew');
}

# create handle bitmaps
sub _createHandleBitmaps {
  my $self = shift;

  # define the v bitmap.
  my $vbits = pack("b10" x 5,
		   "11......11",
		   ".11....11.",
		   "..11..11..",
		   "...1111...",
		   "....11....",
		  );

  $self->{FRAME}->DefineBitmap('v_handle', 10, 5, $vbits);

  # define the h bitmap.
  my $hbits = pack("b5" x 10,
		   "1....",
		   "11...",
		   ".11..",
		   "..11.",
		   "...11",
		   "...11",
		   "..11.",
		   ".11..",
		   "11...",
		   "1....",
		  );

  $self->{FRAME}->DefineBitmap('h_handle', 5, 10, $hbits);
}

# creates the vertical handle
sub _createHandleV {
  my $self = shift;

  my ($col, $row) = $self->{FRAME}->gridSize;

  my $h = $self->{FRAME}->Label(-bitmap => 'v_handle',
				-cursor => 'sb_v_double_arrow',
				-bg     => $bgColor,
				-fg     => $handleColor,
			       )->grid(
				       -column     => 0,
				       -row        => $row,
				       -columnspan => $col,
				      );

  $h->bind('<1>' => [sub {
		       $self->{XY} = [$h->pointerxy];
		     }]);

  $h->bind('<B1-Motion>' => [$self, '_resizeV']);

  $self->{HANDLEV} = $h;
}

# creates the horizontal handle.
sub _createHandleH {
  my $self = shift;

  my ($col, $row) = $self->{FRAME}->gridSize;

  my $h = $self->{FRAME}->Label(-bitmap => 'h_handle',
				-cursor => 'sb_h_double_arrow',
				-bg     => $bgColor,
				-fg     => $handleColor,
			       )->grid(
				       -column  => $col,
				       -row     => 0,
				       -rowspan => $row,
				      );

  $h->bind('<1>' => [sub {
		       $self->{XY} = [$h->pointerxy];
		     }]);

  $h->bind('<B1-Motion>' => [$self, '_resizeH']);

  $self->{HANDLEH} = $h;
}

# called when a horizontal handle is dragged.
sub _resizeH {
  my $self = shift;

  my ($ox, $oy) = @{$self->{XY}};
  my ($cx, $cy) = $self->{HANDLEH}->pointerxy;

  my $dx = $cx - $ox;

  return unless abs($dx) >= $cellWidth;

  # dx > 0 => right => add column
  # dx < 0 => left  => collapse column

  if ($dx > 0) {
    $self->_addColumn('end');
  } else {
    $self->_collapseColumn('end') or return;
  }

  $self->{XY} = [$cx, $cy];
}

# called when the vertical handle is dragged.
sub _resizeV {
  my $self = shift;

  my ($ox, $oy) = @{$self->{XY}};
  my ($cx, $cy) = $self->{HANDLEH}->pointerxy;

  my $dy = $cy - $oy;

  return unless abs($dy) >= $cellHeight;

  # dy > 0 => down => add row
  # dy < 0 => up   => collapse row

  if ($dy > 0) {
    $self->_addRow('end');
  } else {
    $self->_collapseRow('end') or return;
  }

  $self->{XY} = [$cx, $cy];
}

# adds a column at the specified location.
sub _addColumn {
  my ($self, $where) = @_;

  my ($cols, $rows) = $self->{FRAME}->gridSize;

  # get the column number to add.
  my $col = $where;
  if ($where eq 'end') {
    $col = $cols - 1;

  } elsif ($where eq 'menu_right') {
    my $cell    = $self->{MENU_OVER};
    my ($r, $c) = @{$self->{FRAME2CELL}{$cell}};

    $col = $c + 1;

  } elsif ($where eq 'menu_left') {
    my $cell    = $self->{MENU_OVER};
    my ($r, $c) = @{$self->{FRAME2CELL}{$cell}};

    $col = $c;
  }

  # if the column contains a cell with more than one columnspan
  # and this cell extends beyond the current column, then
  # adjust $col to correct this.
  my $topC = my $botC = $col;

  for my $r (0 .. $rows - 2) {
    # just care for merged/missing cells.
    if      ($self->{MERGED} [$r][$col]) {
      # hmmm ...
      #my $s = $self->{CELLCONFIG}[$r][$col]{COLUMNSPAN} + $col;
      #$botC = $s if $s > $botC;
    } elsif (my $ref = $self->{MISSING}[$r][$col]) {
      my $s = $self->{CELLCONFIG}[$ref->[0]][$ref->[1]]{COLUMNSPAN} + $ref->[1];
      $botC = $s        if $s    > $botC;
      $topC = $ref->[1] if $topC > $ref->[1];
    }
  }

  if      ($where eq 'menu_left' && $topC != $col) {
    $col = $topC;
  } elsif ($where eq 'menu_right' && $topC != $col) {
    $col = $botC;
  }

  # now move the columns on right side to make room.
  for my $c (reverse $col .. $cols - 2) {
    $self->_shiftColumn($c, 'right');
  }

  # move over the horizontal handle.
  $self->{HANDLEH}->grid(-column => $cols);

  # and .. insert a new column.
  $self->_addCell($_, $col) for 0 .. $rows - 2;

  # now .. recenter the handle.
  $self->_centerHandles;
}

# shifts a column by one grid unit toward the specified side.
sub _shiftColumn {
  my ($self, $c, $side) = @_;

  my $f = $self->{FRAME};
  my $newC;

  if ($side eq 'right') {
    $newC = $c + 1;
  } else {
    $newC = $c - 1;
  }

  my ($cols, $rows) = $self->{FRAME}->gridSize;

  # move the actual frames.
  for my $r (0 .. $rows - 2) {
    next if $self->{MISSING}[$r][$c];

    my $cell = $self->{CELL2FRAME}[$r][$c];
    $cell->grid(-column => $newC);
  }

  # update the hash structures.
  for my $r (0 .. $rows - 2) {
    if (my $ref = $self->{MISSING}[$r][$c]) {
      $self->{MISSING}[$r][$newC] = $ref;
      next;
    }
    $self->{MISSING}[$r][$newC] = 0;

    $self->_updateCellDB($r, $c, $r, $newC);
  }
}

# deletes a column .. only if empty,
# and if no cells are missing or merged in the column.
sub _collapseColumn {
  my ($self, $col) = @_;

  my ($cols, $rows) = $self->{FRAME}->gridSize;

  # at least one ..
  return undef if $cols == 2;

  # get the column number to collapse.
  if ($col eq 'end') {
    $col = $cols - 2;

  } elsif ($col eq 'menu_post') {
    my $cell    = $self->{MENU_OVER};
    my ($r, $c) = @{$self->{FRAME2CELL}{$cell}};

    $col = $c;
  }

  # make sure there are no missing or merged cells in the column.
  for my $r (0 .. $rows - 2) {
    return undef if $self->{MISSING}[$r][$col] || $self->{MERGED}[$r][$col];
  }

  # make sure the column is empty;
  my $empty = 1;
  $empty &= $self->_isCellEmpty($_, $col) for 0 .. $rows - 2;

  $empty or return undef;

  # delete the column.
  $self->_deleteCell($_, $col) for 0 .. $rows - 2;

  # now move the columns on right side back.
  for my $c ($col + 1 .. $cols - 2) {
    $self->_shiftColumn($c, 'left');
  }

  # move over the horizontal handle and adjust the vertical handle.
  $self->{HANDLEH}->grid(-column     => $cols - 2);
  $self->{HANDLEV}->grid(-columnspan => $cols - 1);

  # now .. recenter the handle.
  $self->_centerHandles;

  return 1;
}

# adds a row at the specified location
sub _addRow {
  my ($self, $where) = @_;

  my ($cols, $rows) = $self->{FRAME}->gridSize;

  # get the row number to add.
  my $row = $where;
  if ($where eq 'end') {
    $row = $rows - 1;

  } elsif ($where eq 'menu_above') {
    my $cell    = $self->{MENU_OVER};
    my ($r, $c) = @{$self->{FRAME2CELL}{$cell}};

    $row = $r;

  } elsif ($where eq 'menu_below') {
    my $cell    = $self->{MENU_OVER};
    my ($r, $c) = @{$self->{FRAME2CELL}{$cell}};

    $row = $r + 1;
  }

  # if the row contains a cell with more than one rowspan
  # and this cell extends beyond the current row, then
  # adjust $row to correct this.
  my $topR = my $botR = $row;

  for my $c (0 .. $cols - 2) {
    # just care for merged/missing cells.
    if      ($self->{MERGED} [$row][$c]) {
      # hmmm ...
      #my $s = $self->{CELLCONFIG}[$row][$c]{ROWSPAN} + $row;
      #$botR = $s if $s > $botR;
    } elsif (my $ref = $self->{MISSING}[$row][$c]) {
      my $s = $self->{CELLCONFIG}[$ref->[0]][$ref->[1]]{ROWSPAN} + $ref->[0];
      $botR = $s        if $s    > $botR;
      $topR = $ref->[0] if $topR > $ref->[0];
    }
  }

  if      ($where eq 'menu_above' && $topR != $row) {
    $row = $topR;
  } elsif ($where eq 'menu_below' && $botR != $row) {
    $row = $botR;
  }

  # now move the rows below to make room.
  for my $r (reverse $row .. $rows - 2) {
    $self->_shiftRow($r, 'down');
  }

  # move over the vertical handle.
  $self->{HANDLEV}->grid(-row => $rows);
  #return;
  # and .. insert a new row.
  $self->_addCell($row, $_) for 0 .. $cols - 2;

  # now .. recenter the handle.
  $self->_centerHandles;
}

# shift a row by one grid unit toward the specified side.
sub _shiftRow {
  my ($self, $r, $side) = @_;

  my $f = $self->{FRAME};
  my $newR;

  if ($side eq 'down') {
    $newR = $r + 1;
  } else {
    $newR = $r - 1;
  }

  my ($cols, $rows) = $f->gridSize;

  # move the actual frames.
  for my $c (0 .. $cols - 2) {
    next if $self->{MISSING}[$r][$c];

    my $cell = $self->{CELL2FRAME}[$r][$c];
    $cell->grid(-row => $newR);
  }

  # update the hash structures.
  for my $c (0 .. $cols - 2) {
    if (my $ref = $self->{MISSING}[$r][$c]) {
      $self->{MISSING}[$newR][$c] = $ref;
      next;
    }
    $self->{MISSING}[$newR][$c] = 0;

    $self->_updateCellDB($r, $c, $newR, $c);
  }
}

# deletes a row .. only if it's empty,
# and if no cells are missing or merged in the row.
sub _collapseRow {
  my ($self, $row) = @_;

  my ($cols, $rows) = $self->{FRAME}->gridSize;

  # at least one ..
  return undef if $rows == 2;

  # get the row number to collapse.
  if ($row eq 'end') {
    $row = $rows - 2;

  } elsif ($row eq 'menu_post') {
    my $cell    = $self->{MENU_OVER};
    my ($r, $c) = @{$self->{FRAME2CELL}{$cell}};

    $row = $r;
  }

  # make sure there are no missing or merged cells in the row.
  for my $c (0 .. $cols - 2) {
    return undef if $self->{MISSING}[$row][$c] || $self->{MERGED}[$row][$c];
  }

  # make sure the row is empty;
  my $empty = 1;
  $empty &= $self->_isCellEmpty($row, $_) for 0 .. $cols - 2;

  $empty or return undef;

  # delete the row.
  $self->_deleteCell($row, $_) for 0 .. $cols - 2;

  # now move the rows below.
  for my $r ($row + 1.. $rows - 2) {
    $self->_shiftRow($r, 'up');
  }

  # move over the vertical handle and adjust the horizontal handle.
  $self->{HANDLEV}->grid(-row        => $rows - 2);
  $self->{HANDLEH}->grid(-rowspan    => $rows - 1);

  # now .. recenter the handle.
  $self->_centerHandles;

  return 1;
}

# creates a new cell at the specified location.
sub _addCell {
  my ($self, $r, $c) = @_;

  my $f = $self->{CELL2FRAME}[$r][$c] = $self->{FRAME}->Frame
    (
     -width       => $cellWidth,
     -height      => $cellHeight,
     -bg          => $self->{CELLBG},
     -borderwidth => 1,
     -relief      => 'ridge',
    )->grid(-column => $c,
	    -row    => $r,
	    -sticky => 'nsew',
	   );

  #print "Added cell $f at $r, $c.\n";
  $self->{FRAME2CELL}{$f} = [$r, $c];

  # indicate that it's empty
  $self->{USED}[$r][$c] = 0;

  # default config.
  $self->{CELLCONFIG}[$r][$c] = {
				 COLUMNSPAN => 1,
				 ROWSPAN    => 1,
				 PADX       => 0,
				 PADY       => 0,
				 STICKY     => '',
				};

  $self->{MISSING}[$r][$c] = 0;
  $self->{MERGED} [$r][$c] = 0;

  # post the menu when right clicked
  $f->bind('<3>' => [$self, '_rightClick', $f]);
  $f->bind('<1>' => [$self, '_leftClick']);

  #print "Making $f.$self a dropsite.\n";
  # indicate that it's a DnD site.
  $self->{DROPSITES}{$f} = $f->DropSite(-dropcommand => [$self, 'dropWidget', $f],
					-droptypes   => ['Local'],
				       );

  $self->{STRING2OBJ}{$f} = $f;
}

# this is called when a user attempts to drop a widget
# onto a cell. It simply checks if the cell is empty or
# not and then calls addWidgetToCell().
sub dropWidget {
  my ($self, $cell) = @_;

  if (@{$self->{WIDGET_MOVE}}) {
    $self->_moveWidget($cell);
    return;
  }

  # get the r,c coords.
  my ($r, $c) = @{$self->{FRAME2CELL}{$cell}};

  # make sure the cell is empty.
  return unless $self->_isCellEmpty($r, $c);

  # add the widget.
  $self->addWidgetToCell($ {$self->{SELREF}}, $r, $c);

  # remove the dropsite.
  $self->{DROPSITES}{$cell}->delete;
  delete $self->{DROPSITES}{$cell};
}

# called when a user tries to move a widget from one cell to another.
sub _moveWidget {
  my ($self, $toCell) = @_;

  # get from coords.
  my ($fromSelf, $fr, $fc) = @{$self->{WIDGET_MOVE}};
  my $fromCell  = $fromSelf->{CELL2FRAME}[$fr][$fc];

  @{$self->{WIDGET_MOVE}} = ();

  # get to coords.
  my ($tr, $tc) = @{$self->{FRAME2CELL}{$toCell}};

  # We have to update the following:
  # {USED}
  # {WIDGETS}
  # {DROPSITES}
  # {DND}
  # {SELECTED}
  # {WIDGET2NAME}

  ($fromSelf->{USED}[$fr][$fc],
   $self->{USED}[$tr][$tc]) = ($self->{USED}[$tr][$tc],
			       $fromSelf->{USED}[$fr][$fc]);

  my $w = $self->{WIDGETS}[$tr][$tc] = $fromSelf->{WIDGETS}[$fr][$fc];
  $fromSelf->{WIDGETS}[$fr][$fc] = undef;

  $fromSelf->{DROPSITES}{$fromCell} = $fromCell->DropSite
    (-dropcommand => [$fromSelf, 'dropWidget', $fromCell],
     -droptypes   => ['Local'],
    );

  $self->{DROPSITES}{$toCell}->delete;
  delete $self->{DROPSITES}{$toCell};

  ($fromSelf->{DND}[$fr][$fc],
   $self->{DND}[$tr][$tc]) = ($self->{DND}[$tr][$tc],
			      $fromSelf->{DND}[$fr][$fc]);

  # move the labImage and labName.
  $self->{USED}[$tr][$tc][0]->pack(-in => $toCell,
				   qw/-side top -fill both -expand 1/);
  $self->{USED}[$tr][$tc][1]->pack(-in => $toCell,
				   qw/-side bottom -fill x/);

  $_->raise for @{$self->{USED}[$tr][$tc]};

  for my $l (@{$self->{USED}[$tr][$tc]}) {
    $l->bind('<3>' => [$self, '_rightClick', $toCell]);
    $l->bind('<1>' => [$self, '_leftClick',  $toCell])
  }

  @{$self->{SELECTED}} = ($self, $tr, $tc);

  $self->{WIDGET2NAME}{$w} = delete $fromSelf->{WIDGET2NAME}{$w};

  # now update the preview.
  $self->updatePreview;
  $fromSelf->updatePreview;
}

# called when user right-clicks on a cell.
sub _rightClick {
  my ($self, $cell) = @_;

  $self->{MENU_OVER} = $cell;
  $self->{MENU}->Post($cell->pointerxy);
}

# called when user left-clicks on a cell.
sub _leftClick {
  my ($self, $cell) = @_;

  unless ($cell) {
    $self->_unselectCell;
    return;
  }

  $self->_selectCell($cell);
  $self->{MENU_OVER} = $cell;
  $self->_configureWidget('menu_post', 0);

  # the DND
  if (0) {
    my ($r, $c) = @{$self->{FRAME2CELL}{$cell}};
    my $name    = $self->{WIDGET2NAME}{$self->{WIDGETS}[$r][$c]};

    $self->{DND}[$r][$c]->configure(
				    -borderwidth => 1,
				    -relief      => 'raised',
				    -text        => $name,
				   );

    @{$self->{WIDGET_MOVE}} = ($self, $r, $c);  # preserve the reference.
  }
}

# selects a cell. This is only visual.
# the bg color of the cell changes. Any previously
# selected cell is unselected first.
sub _selectCell {
  my ($self, $cell) = @_;

  # unselected anything already selected.
  $self->_unselectCell;

  my ($r, $c) = @{$self->{FRAME2CELL}{$cell}};
  my $l       = $self->{USED}[$r][$c];
  $_->configure(-bg => $selColor) for @$l;

  @{$self->{SELECTED}} = ($self, $r, $c);
}

sub _unselectCell {
  my $self = shift;

  my $ref = $self->{SELECTED};
  if (@$ref) {
    my ($s, $r, $c) = @$ref;
    my $l           = $s->{USED}[$r][$c];

    $_->configure(-bg => Tk::NORMAL_BG) for @$l;
  }

  @{$self->{SELECTED}} = ();
}

# adds a widget to the given cell.
sub addWidgetToCell {
  my ($self, $w, $r, $c) = @_;

  # first check to see if ($r, $c) is visible.
  return if $self->{MISSING}[$r][$c];

  # get the cell to be placed into.
  my $cell = $self->{CELL2FRAME}[$r][$c];

  # create a unique name/id for the object.
  my $id   = ++$self->{IDS}{$w};
  my $name = $w . $id;
  my $img  = lc $w;

  # create the object as a child of the {TOP_PARENT} widget.
  # Some widgets need special handling. Those are:
  # 1. (Lab)?Frames: stick them in hierarchically.

  my ($labImage, $labName);

  #print "Checking if $w is a container ($isContainer).\n";
  if ($w =~ $isContainer) {
    #print "Real container ($w).\n";
    # stick in a real labframe.
    # what should I do for a frame?
    $labImage = $self->{TOP_PARENT}->Labelframe(-text => $name);

    my $w2 = $self->new(
			-id          => $self->{ID},
			-parent      => $labImage,
			-top_parent  => $self->{TOP_PARENT},
			-tree        => $self->{TREE},
			-title       => '',
			-name        => $name,
			-rows        => 2,
			-cols        => 2,
			-selref      => $self->{SELREF},
			-icons       => $self->{ICONS},
			-ischild     => 1,
			-prevtop     => $self->{PREV},
			-widget_move => $self->{WIDGET_MOVE},
			-selected    => $self->{SELECTED},
			-ids         => $self->{IDS},
		       );

    $self->{SPECIAL2OBJ}{$labImage} = $w2;
  } else {
    # just put a label with the image.
    $labImage = $self->{TOP_PARENT}->Label((exists $self->{ICONS}{$img} ?
					    (-image => $self->{ICONS}{$img}) :
					    (-bitmap => 'error')),
					  );
  }

  $labImage->pack(-in => $cell, qw/-side top -fill both -expand 1/);
  $labName = $self->{TOP_PARENT}->Label(-text => $name,
				       )->pack(-in => $cell,
					       qw/-side bottom -fill x/);

  $self->{USED}   [$r][$c] = [$labImage, $labName];
  $self->{WIDGETS}[$r][$c] = $w;
  $self->{WIDGET2NAME}{$w} = $name;

  # bind for right/left click.
  for my $l ($labImage, $labName) {
    $l->bind('<3>' => [$self, '_rightClick', $cell]);
    $l->bind('<1>' => [$self, '_leftClick',  $cell])
  }

  # update the preview
  $self->updatePreview;

#  # bind so we can move it around.
#  $self->{DND}[$r][$c] = $labImage->DragDrop(-sitetypes => [qw/Local/],
#					     -event     => '<B1-Motion>',
#					    );
}

# deletes a widget from a cell.
sub _deleteWidget {
  my ($self, $from) = @_;

  my $cell;
  my ($row, $col);

  if ($from eq 'menu_post') {
    $cell = $self->{MENU_OVER};
    ($row, $col) = @{$self->{FRAME2CELL}{$cell}};

  } elsif ($from eq 'selected') {
    return unless @{$self->{SELECTED}};

    ($self, $row, $col) = @{$self->{SELECTED}};
    $cell = $self->{CELL2FRAME}[$row][$col];

  } else {
    $cell = $from;
    ($row, $col) = @{$self->{FRAME2CELL}{$cell}};
  }

  # nothing to delete if cell is empty.
  my $ref = $self->{USED}[$row][$col];
  $ref or return;

  # get the widget
  my $w = $self->{WIDGETS}[$row][$col];

  # indicate it should be destroyed at the next preview update.
  #print "$w should be destroyed!\n";
  #$self->{DESTROY}{$w} = 1;
  push @{$self->{DESTROY}} => $w;

  # kill the labels.
  $_->destroy for @$ref;

  # resize cell to original size.
  $cell->configure(-width  => $cellWidth,
		   -height => $cellHeight);

  # re-instate the drop site.
  $self->{DROPSITES}{$cell} = $cell->DropSite(-dropcommand => [$self, 'dropWidget', $cell],
					      -droptypes   => ['Local'],
					     );

  # clear up data structres.
  $self->{USED}[$row][$col]    = 0;
  $self->{WIDGETS}[$row][$col] = undef;

  # update
  $self->updatePreview;
}

# deletes a cell with its data structures.
sub _deleteCell {
  my ($self, $r, $c) = @_;

  #print "Deleting cell $r, $c.\n";
  my $f = $self->{CELL2FRAME}[$r][$c];
  #print "F is >>$f<<\n";
  $f->destroy;
  $self->{CELL2FRAME}[$r][$c] = undef;
}

# returns whether the cell is empty or not.
sub _isCellEmpty {
  my ($self, $row, $col) = @_;

  return !$self->{USED}[$row][$col];
}

# create the preview window.
# If a toplevel project, then create a toplevel.
# If a child project, then create a frame.
sub _createPreview {
  my $self = shift;

  my $t;

  if ($self->{ISCHILD}) {
    $t = $self->{PREVTOP}->Frame;
  } else {
    $t = $self->{PARENT}->Toplevel;
    $t->protocol(WM_DELETE_WINDOW => [$t, 'withdraw']);
  }
  #print "Preview for $self is $t.\n";
  $self->{PREV} = $t;
}

# hide/unhide the preview window.
sub togglePreview {
  my $self = shift;

  # no separate preview for a child project.
  return if $self->{ISCHILD}; # should never execute

  # toggle.
  if ($self->{PREV}->ismapped) {
    $self->{PREV}->withdraw;
  } else {
    $self->{PREV}->deiconify;
  }
}

sub togglePreview_test {
  my $self = shift;

  # just stick a labframe in (0, 0)
  my $cell = $self->{CELL2FRAME}[0][0];
  my $lf = $self->{PARENT}->Labelframe(#-labelside => 'acrosstop',
				     #-label     => 'test',
				       -text => 'test',
				    )->pack(-in => $cell, qw/-fill both -expand 1/);

  $self->new(-id => 10,
	     -parent => $lf,
	     -tree   => $self->{TREE},
	     -title  => '',
	     -rows   => 2,
	     -cols   => 2,
	     -selref => $self->{SELREF},
	     -icons  => $self->{ICONS},
	     -ischild => 1,
	    );

  $self->{USED}[0][0] = $lf;
}

sub _createMenu {
  my $self = shift;

  $self->{FRAME}->optionAdd('*Menu.BorderWidth' => 1);

  my $m = $self->{FRAME}->Menu(-tearoff => 0,
			       -menuitems =>
			       [
				[Cascade => 'Add ...', -tearoff => 0, -menuitems =>
				 [
				  [Button => 'Row Above',    -command => [$self, '_addRow',    'menu_above']],
				  [Button => 'Row Below',    -command => [$self, '_addRow',    'menu_below']],
				  [Button => 'Column Left',  -command => [$self, '_addColumn', 'menu_left' ]],
				  [Button => 'Column Right', -command => [$self, '_addColumn', 'menu_right']],
				 ]],
				[Cascade => 'Collapse ...', -tearoff => 0, -menuitems =>
				 [
				  [Button => 'Row',    -command => [$self, '_collapseRow',    'menu_post']],
				  [Button => 'Column', -command => [$self, '_collapseColumn', 'menu_post']],
				 ]],
				[Cascade => 'Merge Cell ...', -tearoff => 0, -menuitems =>
				 [
				  [Button => 'Left',  -command => [$self, '_mergeCellsH', 'menu_post', 'left']],
				  [Button => 'Right', -command => [$self, '_mergeCellsH', 'menu_post', 'right']],
				  [Button => 'Up',    -command => [$self, '_mergeCellsV', 'menu_post', 'up']],
				  [Button => 'Down',  -command => [$self, '_mergeCellsV', 'menu_post', 'down']],
				 ]],
				[Cascade => 'Split Cell ...', -tearoff => 0, -menuitems =>
				 [
				  [Button => 'Left Column',  -command => [$self, '_splitCellsH', 'menu_post', 'left']],
				  [Button => 'Right Column', -command => [$self, '_splitCellsH', 'menu_post', 'right']],
				  [Button => 'Top Row',      -command => [$self, '_splitCellsV', 'menu_post', 'up']],
				  [Button => 'Bottom Row',   -command => [$self, '_splitCellsV', 'menu_post', 'down']],
				 ]],
				[Separator => ''],
				[Button => 'Configure Row',    -command => [$self, '_configureRowCol', 'row', 'menu_post']],
				[Button => 'Configure Column', -command => [$self, '_configureRowCol', 'col', 'menu_post']],
				[Separator => ''],
				[Button => 'Configure Widget', -command => [$self, '_configureWidget', 'menu_post', 1]],
				[Button => 'Delete Widget',    -command => [$self, '_deleteWidget',    'menu_post']],
				[Separator => ''],
				[Button => 'Dump Configuration', -command => [$self, 'showConfig']],
			       ]);

  $self->{MENU} = $m;
}

sub _postMenu {

}

# merge two cells that are side by side.
# can only merge two cells horizontally if they have the same columnspan
# can't merge two used cells ..
sub _mergeCellsH {
  my ($self, $from, $side) = @_;

  # first get the coordinates of the first cell to merge.
  my ($row1, $col1);

  if (ref $from) {
    ($row1, $col1) = @$from;

  } elsif ($from eq 'menu_post') {
    my $cell     = $self->{MENU_OVER};
    ($row1, $col1) = @{$self->{FRAME2CELL}{$cell}};
  }

  # get the coordinates of the second cell.
  # and figure out the new coordinates of the merged cell.

  my ($row2, $col2) = ($row1, $col1);
  my ($newR, $newC);  # where to place the new cell.
  my ($misR, $misC);  # which cell will be missing.

  do {
    if ($side eq 'left') {
      #($row2, $col2) = ($row1, $col1 - 1);
      $col2--;
      ($newR, $newC) = ($row2, $col2);
      ($misR, $misC) = ($row1, $col1);

    } else { # right
      #($row2, $col2) = ($row1, $col1 + 1);
      $col2++;
      ($newR, $newC) = ($row1, $col1);
      ($misR, $misC) = ($row2, $col2);
    }
  } while $self->{MISSING}[$row2][$col2];

  # check for corner cases.
  my ($cols, $rows) = $self->{FRAME}->gridSize;

  return if $col2 < 0;
  return if $col2 > $cols - 2;

  # make sure both cells have the same rowspan.
  my $s1 = $self->{CELLCONFIG}[$row1][$col1]{ROWSPAN};
  my $s2 = $self->{CELLCONFIG}[$row2][$col2]{ROWSPAN};

  return unless $s1 == $s2;

  # make sure both cells aren't used.
  my $u1 = $self->{USED}[$row1][$col1];
  my $u2 = $self->{USED}[$row2][$col2];

  return if $u1 && $u2;

  # get the actual widget (if any).
  my $widgets = $u1 || $u2;

  # reparent the widget.
  if ($widgets) {
    for my $widget (@$widgets) {
      $widget->packForget;
      $widget->pack(-in => $self->{CELL2FRAME}[$row1][$col1],
		    qw/-fill both -expand 1/);
    }

    $self->{USED}[$row1][$col1] = $widgets;
  }

  # let the merging begin.
  # first, delete cell2.
  $self->_deleteCell($row2, $col2);
  $self->{MISSING}[$misR][$misC] = [$newR, $newC];

  # now stretch the first cell, and place it correctly.
  # we need to add up their column spans.
  my $newSpan = $self->{CELLCONFIG}[$row1][$col1]{COLUMNSPAN} +
    $self->{CELLCONFIG}[$row2][$col2]{COLUMNSPAN};

  my $f = $self->{CELL2FRAME}[$row1][$col1];
  $f->grid(-column     => $newC,
	   -columnspan => $newSpan);

  $self->{CELLCONFIG}[$row1][$col1]{COLUMNSPAN} = $newSpan;

  # indicate that the cell is merged.
  $self->{MERGED}[$row1][$col1] = 1;

  # update the database if we have to.
  $self->_updateCellDB($row1, $col1, $newR, $newC) unless $newC == $col1;
}

# merge two cells that are above each other.
# can only merge two cells vertically if they have the same rowspan
sub _mergeCellsV {
  my ($self, $from, $side) = @_;

  # first get the coordinates of the first cell to merge.
  my ($row1, $col1);

  if (ref $from) {
    ($row1, $col1) = @$from;

  } elsif ($from eq 'menu_post') {
    my $cell     = $self->{MENU_OVER};
    ($row1, $col1) = @{$self->{FRAME2CELL}{$cell}};
  }

  # get the coordinates of the second cell.
  # and figure out the new coordinates of the merged cell.

  my ($row2, $col2) = ($row1, $col1);
  my ($newR, $newC);  # where to place the new cell.
  my ($misR, $misC);  # which cell will be missing.
  #print "Merging cell ($row1, $col1) $side ..\n";
  do {
    if ($side eq 'up') {
      #($row2, $col2) = ($row1, $col1 - 1);
      $row2--;
      ($newR, $newC) = ($row2, $col2);
      ($misR, $misC) = ($row1, $col1);

    } else { # down
      #($row2, $col2) = ($row1, $col1 + 1);
      $row2++;
      ($newR, $newC) = ($row1, $col1);
      ($misR, $misC) = ($row2, $col2);
    }
  } while $self->{MISSING}[$row2][$col2];
  #print "Merging into ($row2, $col2).\n";

  # check for corner cases.
  my ($cols, $rows) = $self->{FRAME}->gridSize;
  #print "Total size = ($rows, $cols).\n";
  return if $row2 < 0;
  return if $row2 > $rows - 2;

  # make sure both cells have the same columnspan.
  my $s1 = $self->{CELLCONFIG}[$row1][$col1]{COLUMNSPAN};
  my $s2 = $self->{CELLCONFIG}[$row2][$col2]{COLUMNSPAN};

  return unless $s1 == $s2;

  # make sure both cells aren't used.
  my $u1 = $self->{USED}[$row1][$col1];
  my $u2 = $self->{USED}[$row2][$col2];

  return if $u1 && $u2;

  # get the actual widget (if any).
  my $widgets = $u1 || $u2;

  # reparent the widget.
  if ($widgets) {
    for my $widget (@$widgets) {
      $widget->packForget;
      $widget->pack(-in => $self->{CELL2FRAME}[$row1][$col1],
		    qw/-fill both -expand 1/);
    }

    $self->{USED}[$row1][$col1] = $widgets;
  }

  # let the merging begin.
  # first, delete cell2.
  $self->_deleteCell($row2, $col2);
  $self->{MISSING}[$misR][$misC] = [$newR, $newC];

  # now stretch the first cell, and place it correctly.
  # we need to add up their column spans.
  my $newSpan = $self->{CELLCONFIG}[$row1][$col1]{ROWSPAN} +
    $self->{CELLCONFIG}[$row2][$col2]{ROWSPAN};

  my $f = $self->{CELL2FRAME}[$row1][$col1];
  $f->grid(-row     => $newR,
	   -rowspan => $newSpan);
  $self->{CELLCONFIG}[$row1][$col1]{ROWSPAN} = $newSpan;

  # indicate that the cell is merged.
  $self->{MERGED}[$row1][$col1] = 1;

  # update the database if we have to.
  $self->_updateCellDB($row1, $col1, $newR, $newC) unless $newR == $row1;
}

# updates the DB when a cell is moved.
sub _updateCellDB {
  my ($self, $fromR, $fromC, $toR, $toC) = @_;

  my $frame = $self->{CELL2FRAME}[$fromR][$fromC];

  $self->{CELL2FRAME}[$toR]  [$toC]   = $frame;
  $self->{USED}      [$toR]  [$toC]   = $self->{USED}[$fromR][$fromC];
  $self->{CELLCONFIG}[$toR]  [$toC]   = $self->{CELLCONFIG}[$fromR][$fromC];
  $self->{MERGED}    [$toR]  [$toC]   = $self->{MERGED}[$fromR][$fromC];
  $self->{FRAME2CELL}{$frame}         = [$toR, $toC];

  #$self->{CELL2FRAME}[$fromR][$fromC] = undef;

  # widget info.
  my $w = $self->{WIDGETS}[$fromR][$fromC];
  $self->{WIDGETS}[$fromR][$fromC] = undef;
  $self->{WIDGETS}[$toR]  [$toC]   = $w;

  # update all the MISSING stuff ..
  for my $i (1 .. $self->{CELLCONFIG}[$toR][$toC]{ROWSPAN} - 1) {
    #print "Setting (", $toR + $i, ", $toC) to missing.\n";
    $self->{MISSING}   [$toR + $i][$toC] = [$toR, $toC];
    $self->{MERGED}    [$toR + $i][$toC] = 0;
    $self->{CELLCONFIG}[$toR + $i][$toC] = {};
  }
  for my $i (1 .. $self->{CELLCONFIG}[$toR][$toC]{COLUMNSPAN} - 1) {
    #print "Setting ($toR, ", $i + $toC, ") to missing.\n";
    $self->{MISSING}   [$toR][$toC + $i] = [$toR, $toC];
    $self->{MERGED}    [$toR][$toC + $i] = 0;
    $self->{CELLCONFIG}[$toR][$toC + $i] = {};
  }
}

# splits a column from a merged cell.
sub _splitCellsH {
  my ($self, $from, $side) = @_;

  # first get the coordinates of the cell to split.
  my ($row1, $col1);

  if (ref $from) {
    ($row1, $col1) = @$from;

  } elsif ($from eq 'menu_post') {
    my $cell     = $self->{MENU_OVER};
    ($row1, $col1) = @{$self->{FRAME2CELL}{$cell}};
  }

  # now, if the cell isn't merged, then simply don't do anything.
  return unless $self->{MERGED}[$row1][$col1];

  # you can't split any columns if columnspan == 1
  my $cspan = $self->{CELLCONFIG}[$row1][$col1]{COLUMNSPAN};
  return if $cspan == 1;

  my $rspan = $self->{CELLCONFIG}[$row1][$col1]{ROWSPAN};

  # can't split a cell that is used.
  # return unless $self->_isCellEmpty($row1, $col1); # why not?

  # get the actual cell.
  my $cell1 = $self->{CELL2FRAME}[$row1][$col1];

  # now .. get coordinate and info of the column to be split off.
  my ($row2, $col2);
  $row2 = $row1;

  my $oldCol1 = $col1;

  if ($side eq 'right') {
    $col2 = $col1 + $cspan - 1;
  } else { # left column
    $col2 = $col1;
    $col1++;
  }
  #print "Old cell to be placed at ($row1, $col1) from ($row1, $oldCol1).\n";
  #print "New cell to be placed at ($row2, $col2).\n";

  # adjust cell1
  $cspan--;

  $cell1->grid(-columnspan => $cspan,
	       -column     => $col1);
  $self->{CELLCONFIG}[$row1][$oldCol1]{COLUMNSPAN} = $cspan;
  $self->{MERGED}    [$row1][$oldCol1]             = $rspan * $cspan > 1 ? 1 : 0;
  $self->_updateCellDB($row1, $oldCol1, $row1, $col1);

  # now create cell2.
  #print "Creating cell at ($row2, $col2) with spans (1, $rspan).\n";
  $self->_addCell($row2, $col2);
  $self->{CELL2FRAME}[$row2][$col2]->grid(-rowspan => $rspan);
  $self->{CELLCONFIG}[$row2][$col2]{ROWSPAN} = $rspan;
  $self->{MERGED}    [$row2][$col2]          = $rspan > 1 ? 1 : 0;
  $self->_updateCellDB($row2, $col2, $row2, $col2);
}

# splits a row from a merged cell.
sub _splitCellsV {
  my ($self, $from, $side) = @_;

  # first get the coordinates of the cell to split.
  my ($row1, $col1);

  if (ref $from) {
    ($row1, $col1) = @$from;

  } elsif ($from eq 'menu_post') {
    my $cell     = $self->{MENU_OVER};
    ($row1, $col1) = @{$self->{FRAME2CELL}{$cell}};
  }

  # now, if the cell isn't merged, then simply don't do anything.
  return unless $self->{MERGED}[$row1][$col1];

  # you can't split any columns if rowspan == 1
  my $rspan = $self->{CELLCONFIG}[$row1][$col1]{ROWSPAN};
  return if $rspan == 1;

  my $cspan = $self->{CELLCONFIG}[$row1][$col1]{COLUMNSPAN};

  # can't split a cell that is used.
  #return unless $self->_isCellEmpty($row1, $col1);

  # get the actual cell.
  my $cell1 = $self->{CELL2FRAME}[$row1][$col1];

  # now .. get coordinate and info of the column to be split off.
  my ($row2, $col2);
  $col2 = $col1;

  my $oldRow1 = $row1;

  if ($side eq 'bottom') {
    $row2 = $row1 + $rspan - 1;
  } else { # top row
    $row2 = $row1;
    $row1++;
  }
  #print "Old cell to be placed at ($row1, $col1) from ($row1, $oldCol1).\n";
  #print "New cell to be placed at ($row2, $col2).\n";

  # adjust cell1
  $rspan--;
  #print "New columnspan == $cspan.\n";
  $cell1->grid(-rowspan => $rspan,
	       -row     => $row1);
  $self->{CELLCONFIG}[$oldRow1][$col1]{ROWSPAN} = $rspan;
  $self->{MERGED}    [$oldRow1][$col1]          = $rspan * $cspan > 1 ? 1 : 0;
  $self->_updateCellDB($oldRow1, $col1, $row1, $col1);

  # now create cell2.
  #print "Creating cell at ($row2, $col2) with spans (1, $rspan).\n";
  $self->_addCell($row2, $col2);
  $self->{CELL2FRAME}[$row2][$col2]->grid(-columnspan => $cspan);
  $self->{CELLCONFIG}[$row2][$col2]{COLUMNSPAN} = $cspan;
  $self->{MERGED}    [$row2][$col2]             = $cspan > 1 ? 1 : 0;
  $self->_updateCellDB($row2, $col2, $row2, $col2);
}

# for debugging
sub showConfig {
  my $self = shift;

  my $cell     = $self->{MENU_OVER};
  my ($r, $c) = @{$self->{FRAME2CELL}{$cell}};

  print <<EOC;
Start : $r, $c.
Frame : $cell.
COLSP : $self->{CELLCONFIG}[$r][$c]{COLUMNSPAN}.
ROWSP : $self->{CELLCONFIG}[$r][$c]{ROWSPAN}.
EOC
  ;
}

# this function upates the preview window.
sub updatePreview {
  my $self = shift;

  my $t     = $self->{PREV};
  my $child = $self->{ISCHILD};

  my $top;
  if ($child) {
    $top = $self->{PREVTOP};
  } else {
    $top = $t;
  }
  #print "Updating $child ($self) = [$t].\n";
  # update title only if not child.
  $t->title("Preview - $self->{TITLE}") unless $child;

  my ($cols, $rows) = $self->{FRAME}->gridSize;

  # take care of the widgets to be destroyed.
  $_->destroy for @{$self->{DESTROY}};
  $self->{DESTROY} = [];

  # now create/configure widgets.
  for my $r (0 .. $rows - 2) {
    for my $c (0 .. $cols - 2) {
      # ignore missing cells.
      next if $self->{MISSING}[$r][$c];

      # ignore empty locations.
      next unless $self->{USED}[$r][$c];

      # get the actual widget.
      my $w = $self->{WIDGETS}[$r][$c];

      # if we haven't created it before, then do it.
      unless (ref $w) {
	#print "Creating a new $w.\n";
	# get the name.
	my $n = delete $self->{WIDGET2NAME}{$w};

	#print "Getting default args for $w ($n).\n";
	my $args = ZooZ::DefaultArgs->getDefaults($w, $n);

	if ($w eq 'Image') {
	  $w = 'Label'; # switch to Label
	}

	if ($w eq 'LabFrame') {
	  $w = 'Labelframe';
	}

	#print "Args are >>@{[%$args]}<<\n";
	#print "Top is $top.\n";
	$w = $top->$w(%$args);
	$self->{WIDGETS}[$r][$c] = $w;
	$self->{WIDGET2NAME}{$w} = $n;

	# if it's another container, then pack its "preview" frame.
	if (ref($w) =~ $isContainer) {
	  my $t = $self->{SPECIAL2OBJ}{$self->{USED}[$r][$c][0]};

	  #print "Here .. packing $t->{PREV} into $w.\n";
	  $t->{PREV}->pack(-in     => $w,
			   -fill   => 'both',
			   -expand => 1);
	  #$t->{PREV}->raise;
	}
      }

      #print "Griding $w at [$c, $r] in $t.\n";
      #print "Paren of $w is ", $w->parent, " .. but placing in $t.\n";
      $w->grid(
	       -in         => $t,
	       -column     => $c,
	       -row        => $r,
	       -rowspan    => $self->{CELLCONFIG}[$r][$c]{ROWSPAN},
	       -columnspan => $self->{CELLCONFIG}[$r][$c]{COLUMNSPAN},
	      );
      $w->raise;
      #$w->raise unless ref $w =~ $isContainer;
    }
  }

  unless ($child) {
    $_->updatePreview for values %{$self->{SPECIAL2OBJ}};
  }

  # auto-update size of top-level
  $t->geometry('') unless $child;
  $t->update;
}

# called when the user wants to configure a widget.
# simply calls the correct form with the proper parameters.
sub _configureWidget {
  my ($self, $from, $force) = @_;

  my ($cell, $r, $c);
  if      ($from eq 'menu_post') {
    $cell    = $self->{MENU_OVER};
    ($r, $c) = @{$self->{FRAME2CELL}{$cell}};

  } elsif ($from eq 'selected') {
    return unless @{$self->{SELECTED}};

    ($self, $r, $c) = @{$self->{SELECTED}};
    $cell = $self->{CELL2FRAME}[$r][$c];

  } else {
    $cell    = $from;   # hmmm .. not used.
    ($r, $c) = @{$self->{FRAME2CELL}{$cell}};
  }

  # make sure the cell is used.
  return unless $self->{USED}[$r][$c];

  # select the cell.
  $self->_selectCell($cell);
  my $widget  = $self->{WIDGETS}[$r][$c];

  ZooZ::Forms->widgetConf(
			  $self->{PARENT},
			  $self->{ID},
			  $self->{WIDGET2NAME}{$widget},
			  $widget,
			  $force,
			 );
}

sub _configureRowCol {
  my ($self, $rowORcol, $from) = @_;

  my $cell;
  my ($r, $c);

  if ($from eq 'menu_post') {
    $cell = $self->{MENU_OVER};
    ($r, $c) = @{$self->{FRAME2CELL}{$cell}};

  } elsif ($from eq 'selected') {
    return unless @{$self->{SELECTED}};

    ($self, $r, $c) = @{$self->{SELECTED}};
    $cell = $self->{CELL2FRAME}[$r][$c];
  } else {
    $cell = $from;   # hmmm .. not used.
    ($r, $c) = @{$self->{FRAME2CELL}{$cell}};
  }

  my $index;
  if ($rowORcol eq 'row') {
    $index = $r;
  } else { # col
    $index = $c;
  }

  ZooZ::Forms->rowColConf(
			  $self->{PARENT},
			  $self->{ID},
			  $self->{PREV},
			  $rowORcol,
			  $index);
}


1;
